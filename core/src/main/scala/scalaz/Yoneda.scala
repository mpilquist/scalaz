package scalaz

/**
 * The free functor generated by `F`. The Yoneda lemma says that
 * `Yoneda[F,A]` is isomorphic to `F[A]` for any functor `F`.
 * The homomorphism from `Yoneda[F,A]` to `F[A]` exists even when
 * we have forgotten that `F` is a functor.
 * Can be seen as a partially applied `map` for the functor `F`.
 */
abstract class Yoneda[F[_], A] { yo =>
  def apply[B](f: A => B): F[B]

  /** Converts to `F[A]` even without a `Functor` instance for `F` */
  def run: F[A] = apply(a => a)

  /** Converts to `Coyoneda[F,A]` even without a `Functor` instance for `F` */
  def toCoyoneda: Coyoneda[F,A] = new Coyoneda[F, A] {
    type I = A
    val fi = yo.run
    def k(i: A) = i
  }

  /** Simple function composition. Allows map fusion without traversing an `F`. */
  def map[B](f: A => B): Yoneda[F, B] = new Yoneda[F, B] {
    def apply[C](g: B => C) = yo(f andThen g)
  }

  import Id._
  /** `Yoneda[F, _]` is the right Kan extension of `F` along `Id` */
  def toRan: Ran[Id, F, A] = new Ran[Id, F, A] {
    def apply[B](f: A => B) = yo(f)
  }
}

/**
 * The dual view of the Yoneda lemma. Also a free functor on `F`.
 * This is isomorphic to `F` as long as `F` itself is a functor.
 * The homomorphism from `F[A]` to `Coyoneda[F,A]` exists even when
 * `F` is not a functor.
 */
abstract class Coyoneda[F[_], A] { coyo =>
  type I
  def fi: F[I]
  def k(i: I): A

  /** Converts to `F[A]` given that `F` is a functor */
  def run(implicit F: Functor[F]): F[A] =
    F.map(fi)(k)

  /** Converts to `Yoneda[F,A]` given that `F` is a functor */
  def toYoneda(implicit F: Functor[F]): Yoneda[F, A] = new Yoneda[F, A] {
    def apply[B](f: A => B) = F.map(fi)(k _ andThen f)
  }

  /** Simple function composition. Allows map fusion without touching the underlying `F`. */
  def map[B](f: A => B): Coyoneda[F, B] = new Coyoneda[F, B] {
    type I = coyo.I
    val fi = coyo.fi
    def k(i: I) = f(coyo k i)
  }

  import Id._

  /** `Coyoneda[F,_]` is the left Kan extension of `F` along `Id` */
  def toLan: Lan[Id, F, A] = new Lan[Id, F, A] {
    type I = coyo.I
    val v = fi
    def f(i: I) = k(i)
  }
}

object Yoneda {

  /** `Yoneda[F,_]` is a functor for any `F` */
  implicit def yonedaFunctor[F[_]]: Functor[({type λ[α] = Yoneda[F,α]})#λ] =
    new Functor[({type λ[α] = Yoneda[F,α]})#λ] {
      def map[A,B](ya: Yoneda[F,A])(f: A => B) = ya map f
    }

  /** `F[A]` converts to `Yoneda[F,A]` for any functor `F` */
  def apply[F[_]:Functor,A](fa: F[A]) = new Yoneda[F,A] {
    def apply[B](f: A => B) = Functor[F].map(fa)(f)
  }

}

object Coyoneda {
  /** Lift the `I` type member to a parameter.  It is usually more
    * convenient to use `Aux` than a structural type.
    */
  type Aux[F[_], A, I0] = Coyoneda[F, A]{type I = I0}

  /** `F[A]` converts to `Coyoneda[F,A]` for any `F` */
  def lift[F[_],A](fa: F[A]): Aux[F, A, A] = new Coyoneda[F,A] {
    type I = A
    def k(a: A) = a
    val fi = fa
  }

  /** Old name for `lift`. */
  @deprecated("Coyoneda.apply will take a new argument in 7.1; use the forward-compatible `lift' in current code instead", "7.0.7")
  def apply[F[_],A](fa: F[A]) = lift(fa)

  /** `Coyoneda[F,_]` is a functor for any `F` */
  implicit def coyonedaFunctor[F[_]]: Functor[({type λ[α] = Coyoneda[F,α]})#λ] =
    new Functor[({type λ[α] = Coyoneda[F,α]})#λ] {
      def map[A,B](ya: Coyoneda[F,A])(f: A => B) = ya map f
    }

}
